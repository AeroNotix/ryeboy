
;;;;    proto.lisp

;;; Generated by the protocol buffer compiler.  DO NOT EDIT!


(cl:in-package #:common-lisp-user)
(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package '#:io.riemann.riemann)
    (make-package '#:io.riemann.riemann :use nil)))
(in-package #:io.riemann.riemann)
(cl:declaim #.com.google.base:*optimize-default*)

(cl:defclass state (pb:protocol-buffer)
  (
  (time
   :accessor time
   :initform 0
   :type (cl:signed-byte 64))
  (state
   :accessor state
   :initform (pb:string-field "")
   :type pb::%sf%)
  (service
   :accessor service
   :initform (pb:string-field "")
   :type pb::%sf%)
  (host
   :accessor host
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (once
   :accessor once
   :initform cl:nil
   :type cl:boolean)
  (tags
   :accessor tags
   :initform (cl:make-array
              0
              :element-type 'pb::%sf%
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector pb::%sf%))
  (ttl
   :accessor ttl
   :initform 0f0
   :type cl:single-float)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 8))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'state))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'time))


(cl:defmethod (cl:setf time) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-time)
  (cl:defgeneric has-time (proto)))
(cl:defmethod has-time ((self state))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-time))

(cl:unless (cl:fboundp 'clear-time)
  (cl:defgeneric clear-time (proto)))
(cl:defmethod clear-time ((self state))
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-time))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'state))


(cl:defmethod (cl:setf state) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-state)
  (cl:defgeneric has-state (proto)))
(cl:defmethod has-state ((self state))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-state))

(cl:unless (cl:fboundp 'clear-state)
  (cl:defgeneric clear-state (proto)))
(cl:defmethod clear-state ((self state))
  (cl:setf (cl:slot-value self 'state) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-state))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'service))


(cl:defmethod (cl:setf service) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-service)
  (cl:defgeneric has-service (proto)))
(cl:defmethod has-service ((self state))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-service))

(cl:unless (cl:fboundp 'clear-service)
  (cl:defgeneric clear-service (proto)))
(cl:defmethod clear-service ((self state))
  (cl:setf (cl:slot-value self 'service) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-service))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'host))


(cl:defmethod (cl:setf host) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-host)
  (cl:defgeneric has-host (proto)))
(cl:defmethod has-host ((self state))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-host))

(cl:unless (cl:fboundp 'clear-host)
  (cl:defgeneric clear-host (proto)))
(cl:defmethod clear-host ((self state))
  (cl:setf (cl:slot-value self 'host) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-host))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'description))


(cl:defmethod (cl:setf description) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self state))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-description))

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self state))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-description))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'once))


(cl:defmethod (cl:setf once) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-once)
  (cl:defgeneric has-once (proto)))
(cl:defmethod has-once ((self state))
  (cl:logbitp 5 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-once))

(cl:unless (cl:fboundp 'clear-once)
  (cl:defgeneric clear-once (proto)))
(cl:defmethod clear-once ((self state))
  (cl:setf (cl:slot-value self 'once) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-once))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'tags))

(cl:unless (cl:fboundp 'clear-tags)
  (cl:defgeneric clear-tags (proto)))
(cl:defmethod clear-tags ((self state))
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-tags))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'ttl))


(cl:defmethod (cl:setf ttl) :after (x (self state))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-ttl)
  (cl:defgeneric has-ttl (proto)))
(cl:defmethod has-ttl ((self state))
  (cl:logbitp 7 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-ttl))

(cl:unless (cl:fboundp 'clear-ttl)
  (cl:defgeneric clear-ttl (proto)))
(cl:defmethod clear-ttl ((self state))
  (cl:setf (cl:slot-value self 'ttl) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-ttl))


(cl:defmethod cl:print-object ((self state) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_time: ~s" (time self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_state: ~s" (state self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_service: ~s" (service self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_host: ~s" (host self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_once: ~s" (once self)))
      (cl:format stream " ~_tags: ~s" (tags self))
      (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_ttl: ~s" (ttl self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self state))
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'state) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'service) (pb:string-field "")))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'host) (pb:string-field "")))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'once) cl:nil)
  (cl:setf (cl:slot-value self 'ttl) 0f0)
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self state))
  cl:t)

(cl:defmethod pb:octet-size ((self state))
  (cl:let ((size 0))
    ;; optional int64 time = 1[json_name = "time"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time))))))
    ;; optional string state = 2[json_name = "state"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'state))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string service = 3[json_name = "service"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'service))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string host = 4[json_name = "host"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'host))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string description = 5[json_name = "description"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; optional bool once = 6[json_name = "once"];
    (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional float ttl = 8[json_name = "ttl"];
    (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; repeated string tags = 7[json_name = "tags"];
    (cl:let* ((x (cl:slot-value self 'tags))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:aref x i))))
  (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self state) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int64 time = 1[json_name = "time"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time)))))
  ;; optional string state = 2[json_name = "state"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'state) 'pb::%octets%))))
  ;; optional string service = 3[json_name = "service"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'service) 'pb::%octets%))))
  ;; optional string host = 4[json_name = "host"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'host) 'pb::%octets%))))
  ;; optional string description = 5[json_name = "description"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; optional bool once = 6[json_name = "once"];
  (cl:when (cl:logbitp 5 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 48))
    (cl:setf index
             (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'once))))
  ;; repeated string tags = 7[json_name = "tags"];
  (cl:let* ((v (cl:slot-value self 'tags))
            (length (cl:length v)))
    (cl:dotimes (i length)
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%octets%)))))
  ;; optional float ttl = 8[json_name = "ttl"];
  (cl:when (cl:logbitp 7 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 69))
    (cl:setf index
             (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'ttl))))
  index)

(cl:defmethod pb:merge-from-array ((self state) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; optional int64 time = 1[json_name = "time"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'time) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string state = 2[json_name = "state"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'state) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string service = 3[json_name = "service"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'service) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string host = 4[json_name = "host"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'host) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string description = 5[json_name = "description"];
        ((5)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'description) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional bool once = 6[json_name = "once"];
        ((6)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-boolean-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'once) value)
                (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated string tags = 7[json_name = "tags"];
        ((7)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:vector-push-extend (pb:string-field value) (cl:slot-value self 'tags))
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional float ttl = 8[json_name = "ttl"];
        ((8)
          (cl:cond
            ((cl:= wire-type wire-format:+fixed32+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-single-float-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'ttl) value)
                (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self state) (from state))
  (cl:let ((v (cl:slot-value self 'tags))
           (vf (cl:slot-value from 'tags)))
    (cl:dotimes (i (cl:length vf))
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'time) (cl:slot-value from 'time))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'state) (cl:slot-value from 'state))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'service) (cl:slot-value from 'service))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'host) (cl:slot-value from 'host))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 5 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'once) (cl:slot-value from 'once))
    (cl:setf (cl:ldb (cl:byte 1 5) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 7 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'ttl) (cl:slot-value from 'ttl))
    (cl:setf (cl:ldb (cl:byte 1 7) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass event (pb:protocol-buffer)
  (
  (time
   :accessor time
   :initform 0
   :type (cl:signed-byte 64))
  (state
   :accessor state
   :initform (pb:string-field "")
   :type pb::%sf%)
  (service
   :accessor service
   :initform (pb:string-field "")
   :type pb::%sf%)
  (host
   :accessor host
   :initform (pb:string-field "")
   :type pb::%sf%)
  (description
   :accessor description
   :initform (pb:string-field "")
   :type pb::%sf%)
  (tags
   :accessor tags
   :initform (cl:make-array
              0
              :element-type 'pb::%sf%
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector pb::%sf%))
  (ttl
   :accessor ttl
   :initform 0f0
   :type cl:single-float)
  (attributes
   :accessor attributes
   :initform (cl:make-array
              0
              :element-type 'io.riemann.riemann::attribute
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector io.riemann.riemann::attribute))
  (time-micros
   :accessor time-micros
   :initform 0
   :type (cl:signed-byte 64))
  (metric-sint64
   :accessor metric-sint64
   :initform 0
   :type (cl:signed-byte 64))
  (metric-d
   :accessor metric-d
   :initform 0d0
   :type cl:double-float)
  (metric-f
   :accessor metric-f
   :initform 0f0
   :type cl:single-float)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 12))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'event))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'time))


(cl:defmethod (cl:setf time) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-time)
  (cl:defgeneric has-time (proto)))
(cl:defmethod has-time ((self event))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-time))

(cl:unless (cl:fboundp 'clear-time)
  (cl:defgeneric clear-time (proto)))
(cl:defmethod clear-time ((self event))
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-time))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'state))


(cl:defmethod (cl:setf state) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-state)
  (cl:defgeneric has-state (proto)))
(cl:defmethod has-state ((self event))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-state))

(cl:unless (cl:fboundp 'clear-state)
  (cl:defgeneric clear-state (proto)))
(cl:defmethod clear-state ((self event))
  (cl:setf (cl:slot-value self 'state) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-state))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'service))


(cl:defmethod (cl:setf service) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-service)
  (cl:defgeneric has-service (proto)))
(cl:defmethod has-service ((self event))
  (cl:logbitp 2 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-service))

(cl:unless (cl:fboundp 'clear-service)
  (cl:defgeneric clear-service (proto)))
(cl:defmethod clear-service ((self event))
  (cl:setf (cl:slot-value self 'service) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-service))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'host))


(cl:defmethod (cl:setf host) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-host)
  (cl:defgeneric has-host (proto)))
(cl:defmethod has-host ((self event))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-host))

(cl:unless (cl:fboundp 'clear-host)
  (cl:defgeneric clear-host (proto)))
(cl:defmethod clear-host ((self event))
  (cl:setf (cl:slot-value self 'host) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-host))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'description))


(cl:defmethod (cl:setf description) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-description)
  (cl:defgeneric has-description (proto)))
(cl:defmethod has-description ((self event))
  (cl:logbitp 4 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-description))

(cl:unless (cl:fboundp 'clear-description)
  (cl:defgeneric clear-description (proto)))
(cl:defmethod clear-description ((self event))
  (cl:setf (cl:slot-value self 'description) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-description))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'tags))

(cl:unless (cl:fboundp 'clear-tags)
  (cl:defgeneric clear-tags (proto)))
(cl:defmethod clear-tags ((self event))
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-tags))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'ttl))


(cl:defmethod (cl:setf ttl) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-ttl)
  (cl:defgeneric has-ttl (proto)))
(cl:defmethod has-ttl ((self event))
  (cl:logbitp 6 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-ttl))

(cl:unless (cl:fboundp 'clear-ttl)
  (cl:defgeneric clear-ttl (proto)))
(cl:defmethod clear-ttl ((self event))
  (cl:setf (cl:slot-value self 'ttl) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-ttl))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'attributes))

(cl:unless (cl:fboundp 'clear-attributes)
  (cl:defgeneric clear-attributes (proto)))
(cl:defmethod clear-attributes ((self event))
  (cl:setf (cl:slot-value self 'attributes)
           (cl:make-array 0 :element-type 'io.riemann.riemann::attribute
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-attributes))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'time-micros))


(cl:defmethod (cl:setf time-micros) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-time-micros)
  (cl:defgeneric has-time-micros (proto)))
(cl:defmethod has-time-micros ((self event))
  (cl:logbitp 8 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-time-micros))

(cl:unless (cl:fboundp 'clear-time-micros)
  (cl:defgeneric clear-time-micros (proto)))
(cl:defmethod clear-time-micros ((self event))
  (cl:setf (cl:slot-value self 'time-micros) 0)
  (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-time-micros))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'metric-sint64))


(cl:defmethod (cl:setf metric-sint64) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-metric-sint64)
  (cl:defgeneric has-metric-sint64 (proto)))
(cl:defmethod has-metric-sint64 ((self event))
  (cl:logbitp 9 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-metric-sint64))

(cl:unless (cl:fboundp 'clear-metric-sint64)
  (cl:defgeneric clear-metric-sint64 (proto)))
(cl:defmethod clear-metric-sint64 ((self event))
  (cl:setf (cl:slot-value self 'metric-sint64) 0)
  (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-metric-sint64))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'metric-d))


(cl:defmethod (cl:setf metric-d) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-metric-d)
  (cl:defgeneric has-metric-d (proto)))
(cl:defmethod has-metric-d ((self event))
  (cl:logbitp 10 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-metric-d))

(cl:unless (cl:fboundp 'clear-metric-d)
  (cl:defgeneric clear-metric-d (proto)))
(cl:defmethod clear-metric-d ((self event))
  (cl:setf (cl:slot-value self 'metric-d) 0d0)
  (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-metric-d))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'metric-f))


(cl:defmethod (cl:setf metric-f) :after (x (self event))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-metric-f)
  (cl:defgeneric has-metric-f (proto)))
(cl:defmethod has-metric-f ((self event))
  (cl:logbitp 11 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-metric-f))

(cl:unless (cl:fboundp 'clear-metric-f)
  (cl:defgeneric clear-metric-f (proto)))
(cl:defmethod clear-metric-f ((self event))
  (cl:setf (cl:slot-value self 'metric-f) 0f0)
  (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-metric-f))


(cl:defmethod cl:print-object ((self event) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_time: ~s" (time self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_state: ~s" (state self)))
      (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_service: ~s" (service self)))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_host: ~s" (host self)))
      (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_description: ~s" (description self)))
      (cl:format stream " ~_tags: ~s" (tags self))
      (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_ttl: ~s" (ttl self)))
      (cl:format stream " ~_attributes: ~s" (attributes self))
      (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_time-micros: ~s" (time-micros self)))
      (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_metric-sint64: ~s" (metric-sint64 self)))
      (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_metric-d: ~s" (metric-d self)))
      (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_metric-f: ~s" (metric-f self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self event))
  (cl:setf (cl:slot-value self 'time) 0)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'state) (pb:string-field "")))
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'service) (pb:string-field "")))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'host) (pb:string-field "")))
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (pb:string-field "")))
  (cl:setf (cl:slot-value self 'ttl) 0f0)
  (cl:setf (cl:slot-value self 'time-micros) 0)
  (cl:setf (cl:slot-value self 'metric-sint64) 0)
  (cl:setf (cl:slot-value self 'metric-d) 0d0)
  (cl:setf (cl:slot-value self 'metric-f) 0f0)
  (cl:setf (cl:slot-value self 'tags)
           (cl:make-array
            0
            :element-type 'pb::%sf%
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'attributes)
           (cl:make-array 0 :element-type 'io.riemann.riemann::attribute
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self event))
  (cl:let* ((x (cl:slot-value self 'attributes))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self event))
  (cl:let ((size 0))
    ;; optional int64 time = 1[json_name = "time"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time))))))
    ;; optional string state = 2[json_name = "state"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'state))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string service = 3[json_name = "service"];
    (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'service))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string host = 4[json_name = "host"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'host))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string description = 5[json_name = "description"];
    (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'description))))
        (cl:+ s (varint:length32 s)))))
    ;; optional float ttl = 8[json_name = "ttl"];
    (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; optional int64 time_micros = 10[json_name = "timeMicros"];
    (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time-micros))))))
    ;; optional sint64 metric_sint64 = 13[json_name = "metricSint64"];
    (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 (varint:length64 (wire-format:zig-zag-encode64 (cl:slot-value self 'metric-sint64))))))
    ;; optional double metric_d = 14[json_name = "metricD"];
    (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 8)))
    ;; optional float metric_f = 15[json_name = "metricF"];
    (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 4)))
    ;; repeated string tags = 7[json_name = "tags"];
    (cl:let* ((x (cl:slot-value self 'tags))
              (length (cl:length x)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:aref x i))))
  (cl:+ s (varint:length32 s))))))
    ;; repeated .Attribute attributes = 9[json_name = "attributes"];
    (cl:let* ((v (cl:slot-value self 'attributes))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self event) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional int64 time = 1[json_name = "time"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 8))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time)))))
  ;; optional string state = 2[json_name = "state"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'state) 'pb::%octets%))))
  ;; optional string service = 3[json_name = "service"];
  (cl:when (cl:logbitp 2 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'service) 'pb::%octets%))))
  ;; optional string host = 4[json_name = "host"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'host) 'pb::%octets%))))
  ;; optional string description = 5[json_name = "description"];
  (cl:when (cl:logbitp 4 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'description) 'pb::%octets%))))
  ;; repeated string tags = 7[json_name = "tags"];
  (cl:let* ((v (cl:slot-value self 'tags))
            (length (cl:length v)))
    (cl:dotimes (i length)
      (cl:setf index (varint:encode-uint32-carefully buffer index limit 58))
      (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%octets%)))))
  ;; optional float ttl = 8[json_name = "ttl"];
  (cl:when (cl:logbitp 6 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 69))
    (cl:setf index
             (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'ttl))))
  ;; repeated .Attribute attributes = 9[json_name = "attributes"];
  (cl:let* ((v (cl:slot-value self 'attributes))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 74))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; optional int64 time_micros = 10[json_name = "timeMicros"];
  (cl:when (cl:logbitp 8 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 80))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (cl:ldb (cl:byte 64 0) (cl:slot-value self 'time-micros)))))
  ;; optional sint64 metric_sint64 = 13[json_name = "metricSint64"];
  (cl:when (cl:logbitp 9 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 104))
    (cl:setf index
             (varint:encode-uint64-carefully buffer index limit (wire-format:zig-zag-encode64 (cl:slot-value self 'metric-sint64)))))
  ;; optional double metric_d = 14[json_name = "metricD"];
  (cl:when (cl:logbitp 10 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 113))
    (cl:setf index
             (wire-format:write-double-float-carefully buffer index limit (cl:slot-value self 'metric-d))))
  ;; optional float metric_f = 15[json_name = "metricF"];
  (cl:when (cl:logbitp 11 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 125))
    (cl:setf index
             (wire-format:write-single-float-carefully buffer index limit (cl:slot-value self 'metric-f))))
  index)

(cl:defmethod pb:merge-from-array ((self event) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; optional int64 time = 1[json_name = "time"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'time) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string state = 2[json_name = "state"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'state) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string service = 3[json_name = "service"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'service) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string host = 4[json_name = "host"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'host) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string description = 5[json_name = "description"];
        ((5)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'description) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated string tags = 7[json_name = "tags"];
        ((7)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:vector-push-extend (pb:string-field value) (cl:slot-value self 'tags))
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional float ttl = 8[json_name = "ttl"];
        ((8)
          (cl:cond
            ((cl:= wire-type wire-format:+fixed32+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-single-float-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'ttl) value)
                (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .Attribute attributes = 9[json_name = "attributes"];
        ((9)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'io.riemann.riemann::attribute)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'attributes)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional int64 time_micros = 10[json_name = "timeMicros"];
        ((10)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (varint:parse-int64-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'time-micros) value)
                (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional sint64 metric_sint64 = 13[json_name = "metricSint64"];
        ((13)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (cl:multiple-value-bind (x new-index)
    (varint:parse-uint64-carefully buffer index limit)
  (cl:values (wire-format:zig-zag-decode64 x) new-index))
                (cl:setf (cl:slot-value self 'metric-sint64) value)
                (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional double metric_d = 14[json_name = "metricD"];
        ((14)
          (cl:cond
            ((cl:= wire-type wire-format:+fixed64+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-double-float-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'metric-d) value)
                (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional float metric_f = 15[json_name = "metricF"];
        ((15)
          (cl:cond
            ((cl:= wire-type wire-format:+fixed32+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-single-float-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'metric-f) value)
                (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self event) (from event))
  (cl:let ((v (cl:slot-value self 'tags))
           (vf (cl:slot-value from 'tags)))
    (cl:dotimes (i (cl:length vf))
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'attributes))
            (vf (cl:slot-value from 'attributes))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'time) (cl:slot-value from 'time))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'state) (cl:slot-value from 'state))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 2 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'service) (cl:slot-value from 'service))
    (cl:setf (cl:ldb (cl:byte 1 2) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'host) (cl:slot-value from 'host))
    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 4 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'description) (cl:slot-value from 'description))
    (cl:setf (cl:ldb (cl:byte 1 4) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 6 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'ttl) (cl:slot-value from 'ttl))
    (cl:setf (cl:ldb (cl:byte 1 6) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 8 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'time-micros) (cl:slot-value from 'time-micros))
    (cl:setf (cl:ldb (cl:byte 1 8) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 9 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'metric-sint64) (cl:slot-value from 'metric-sint64))
    (cl:setf (cl:ldb (cl:byte 1 9) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 10 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'metric-d) (cl:slot-value from 'metric-d))
    (cl:setf (cl:ldb (cl:byte 1 10) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 11 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'metric-f) (cl:slot-value from 'metric-f))
    (cl:setf (cl:ldb (cl:byte 1 11) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass query (pb:protocol-buffer)
  (
  (string
   :accessor string
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 1))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'query))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'string))


(cl:defmethod (cl:setf string) :after (x (self query))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-string)
  (cl:defgeneric has-string (proto)))
(cl:defmethod has-string ((self query))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-string))

(cl:unless (cl:fboundp 'clear-string)
  (cl:defgeneric clear-string (proto)))
(cl:defmethod clear-string ((self query))
  (cl:setf (cl:slot-value self 'string) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-string))


(cl:defmethod cl:print-object ((self query) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_string: ~s" (string self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self query))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'string) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self query))
  cl:t)

(cl:defmethod pb:octet-size ((self query))
  (cl:let ((size 0))
    ;; optional string string = 1[json_name = "string"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'string))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self query) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional string string = 1[json_name = "string"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'string) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self query) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; optional string string = 1[json_name = "string"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'string) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self query) (from query))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'string) (cl:slot-value from 'string))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  )


(cl:defclass msg (pb:protocol-buffer)
  (
  (ok
   :accessor ok
   :initform cl:nil
   :type cl:boolean)
  (error
   :accessor error
   :initform (pb:string-field "")
   :type pb::%sf%)
  (states
   :accessor states
   :initform (cl:make-array
              0
              :element-type 'io.riemann.riemann::state
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector io.riemann.riemann::state))
  (query
   :writer (cl:setf query)
   :initform cl:nil
   :type (cl:or cl:null io.riemann.riemann::query))
  (events
   :accessor events
   :initform (cl:make-array
              0
              :element-type 'io.riemann.riemann::event
              :fill-pointer 0 :adjustable cl:t)
   :type (cl:vector io.riemann.riemann::event))
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 5))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'msg))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'ok))


(cl:defmethod (cl:setf ok) :after (x (self msg))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-ok)
  (cl:defgeneric has-ok (proto)))
(cl:defmethod has-ok ((self msg))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-ok))

(cl:unless (cl:fboundp 'clear-ok)
  (cl:defgeneric clear-ok (proto)))
(cl:defmethod clear-ok ((self msg))
  (cl:setf (cl:slot-value self 'ok) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-ok))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'error))


(cl:defmethod (cl:setf error) :after (x (self msg))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-error)
  (cl:defgeneric has-error (proto)))
(cl:defmethod has-error ((self msg))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-error))

(cl:unless (cl:fboundp 'clear-error)
  (cl:defgeneric clear-error (proto)))
(cl:defmethod clear-error ((self msg))
  (cl:setf (cl:slot-value self 'error) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-error))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'states))

(cl:unless (cl:fboundp 'clear-states)
  (cl:defgeneric clear-states (proto)))
(cl:defmethod clear-states ((self msg))
  (cl:setf (cl:slot-value self 'states)
           (cl:make-array 0 :element-type 'io.riemann.riemann::state
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-states))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'query))

(cl:unless (cl:fboundp 'query)
  (cl:defgeneric query (proto)))
(cl:defmethod query ((self msg))
  (cl:let ((result (cl:slot-value self 'query)))
    (cl:when (cl:null result)
      (cl:setf result (cl:make-instance 'io.riemann.riemann::query))
      (cl:setf (cl:slot-value self 'query) result))
      (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1)
    result))

(cl:defmethod (cl:setf query) :after (x (self msg))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-query)
  (cl:defgeneric has-query (proto)))
(cl:defmethod has-query ((self msg))
  (cl:logbitp 3 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-query))

(cl:unless (cl:fboundp 'clear-query)
  (cl:defgeneric clear-query (proto)))
(cl:defmethod clear-query ((self msg))
  (cl:setf (cl:slot-value self 'query) cl:nil)
  (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-query))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'events))

(cl:unless (cl:fboundp 'clear-events)
  (cl:defgeneric clear-events (proto)))
(cl:defmethod clear-events ((self msg))
  (cl:setf (cl:slot-value self 'events)
           (cl:make-array 0 :element-type 'io.riemann.riemann::event
            :fill-pointer 0 :adjustable cl:t))
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-events))


(cl:defmethod cl:print-object ((self msg) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_ok: ~s" (ok self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_error: ~s" (error self)))
      (cl:format stream " ~_states: ~s" (states self))
      (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_query: ~s" (query self)))
      (cl:format stream " ~_events: ~s" (events self))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self msg))
  (cl:setf (cl:slot-value self 'ok) cl:nil)
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'error) (pb:string-field "")))
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'query) cl:nil))
  (cl:setf (cl:slot-value self 'states)
           (cl:make-array 0 :element-type 'io.riemann.riemann::state
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self 'events)
           (cl:make-array 0 :element-type 'io.riemann.riemann::event
            :fill-pointer 0 :adjustable cl:t))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self msg))
  (cl:let* ((x (cl:slot-value self 'events))
            (length (cl:length x)))
    (cl:dotimes (i length)
      (cl:unless (pb:is-initialized (cl:aref x i))
        (cl:return-from pb:is-initialized cl:nil))))
  cl:t)

(cl:defmethod pb:octet-size ((self msg))
  (cl:let ((size 0))
    ;; optional bool ok = 2[json_name = "ok"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size
        (cl:+ 1 1)))
    ;; optional string error = 3[json_name = "error"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'error))))
        (cl:+ s (varint:length32 s)))))
    ;; optional .Query query = 5[json_name = "query"];
    (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
      (cl:let ((s (pb:octet-size (cl:slot-value self 'query))))
        (cl:incf size (cl:+ 1 s (varint:length32 s)))))
    ;; repeated .State states = 4[json_name = "states"];
    (cl:let* ((v (cl:slot-value self 'states))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    ;; repeated .Event events = 6[json_name = "events"];
    (cl:let* ((v (cl:slot-value self 'events))
              (length (cl:length v)))
      (cl:incf size (cl:* 1 length))
      (cl:dotimes (i length)
        (cl:let ((s (pb:octet-size (cl:aref v i))))
          (cl:incf size (cl:+ s (varint:length32 s))))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self msg) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; optional bool ok = 2[json_name = "ok"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 16))
    (cl:setf index
             (wire-format:write-boolean-carefully buffer index limit (cl:slot-value self 'ok))))
  ;; optional string error = 3[json_name = "error"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 26))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'error) 'pb::%octets%))))
  ;; repeated .State states = 4[json_name = "states"];
  (cl:let* ((v (cl:slot-value self 'states))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 34))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  ;; optional .Query query = 5[json_name = "query"];
  (cl:when (cl:logbitp 3 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 42))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:slot-value self 'query) 'pb::%cached-size%)))
    (cl:setf index (pb:serialize (cl:slot-value self 'query) buffer index limit)))
  ;; repeated .Event events = 6[json_name = "events"];
  (cl:let* ((v (cl:slot-value self 'events))
            (length (cl:length v)))
    (cl:loop for i from 0 below length do
       (cl:setf index (varint:encode-uint32-carefully buffer index limit 50))
       (cl:setf index (varint:encode-uint32-carefully buffer index limit (cl:slot-value (cl:aref v i) 'pb::%cached-size%)))
       (cl:setf index (pb:serialize (cl:aref v i) buffer index limit))))
  index)

(cl:defmethod pb:merge-from-array ((self msg) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; optional bool ok = 2[json_name = "ok"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+varint+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-boolean-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'ok) value)
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string error = 3[json_name = "error"];
        ((3)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'error) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .State states = 4[json_name = "states"];
        ((4)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'io.riemann.riemann::state)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'states)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional .Query query = 5[json_name = "query"];
        ((5)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:slot-value self 'query)))
                  (cl:when (cl:null message)
                    (cl:setf message (cl:make-instance 'io.riemann.riemann::query))
                    (cl:setf (cl:slot-value self 'query) message)
                    (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment)))))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; repeated .Event events = 6[json_name = "events"];
        ((6)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (length new-index)
                  (varint:parse-uint31-carefully buffer index limit)
                (cl:when (cl:> (cl:+ new-index length) limit)
                  (cl:error 'wire-format:data-exhausted))
                (cl:let ((message (cl:make-instance 'io.riemann.riemann::event)))
                  (cl:setf index (pb:merge-from-array message buffer new-index (cl:+ new-index length)))
                  (cl:when (cl:/= index (cl:+ new-index length))
                    (cl:error 'wire-format:alignment))
                  (cl:vector-push-extend message (cl:slot-value self 'events)))))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self msg) (from msg))
  (cl:let* ((v (cl:slot-value self 'states))
            (vf (cl:slot-value from 'states))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:let* ((v (cl:slot-value self 'events))
            (vf (cl:slot-value from 'events))
            (length (cl:length vf)))
    (cl:loop for i from 0 below length do
      (cl:vector-push-extend (cl:aref vf i) v)))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'ok) (cl:slot-value from 'ok))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'error) (cl:slot-value from 'error))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 3 (cl:slot-value from '%has-bits%))
    (cl:let ((message (cl:slot-value self 'query)))
      (cl:when (cl:null message)
        (cl:setf message (cl:make-instance 'io.riemann.riemann::query))
        (cl:setf (cl:slot-value self 'query) message)
        (cl:setf (cl:ldb (cl:byte 1 3) (cl:slot-value self '%has-bits%)) 1))
     (pb:merge-from-message message (cl:slot-value from 'query))))
  )


(cl:defclass attribute (pb:protocol-buffer)
  (
  (key
   :accessor key
   :initform (pb:string-field "")
   :type pb::%sf%)
  (value
   :accessor value
   :initform (pb:string-field "")
   :type pb::%sf%)
  (%has-bits%
   :accessor %has-bits%
   :initform 0
   :type (cl:unsigned-byte 2))
  (pb::%cached-size%
   :initform 0
   :type (cl:integer 0 #.(cl:1- cl:array-dimension-limit)))
  ))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'attribute))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'key))


(cl:defmethod (cl:setf key) :after (x (self attribute))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-key)
  (cl:defgeneric has-key (proto)))
(cl:defmethod has-key ((self attribute))
  (cl:logbitp 0 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-key))

(cl:unless (cl:fboundp 'clear-key)
  (cl:defgeneric clear-key (proto)))
(cl:defmethod clear-key ((self attribute))
  (cl:setf (cl:slot-value self 'key) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-key))

(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'value))


(cl:defmethod (cl:setf value) :after (x (self attribute))
  (cl:declare (cl:ignore x))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))

(cl:unless (cl:fboundp 'has-value)
  (cl:defgeneric has-value (proto)))
(cl:defmethod has-value ((self attribute))
  (cl:logbitp 1 (cl:slot-value self '%has-bits%)))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'has-value))

(cl:unless (cl:fboundp 'clear-value)
  (cl:defgeneric clear-value (proto)))
(cl:defmethod clear-value ((self attribute))
  (cl:setf (cl:slot-value self 'value) (pb:string-field ""))
  (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 0)
  (cl:values))
(cl:eval-when (:load-toplevel :compile-toplevel :execute)
  (cl:export 'clear-value))


(cl:defmethod cl:print-object ((self attribute) stream)
  (cl:pprint-logical-block (stream cl:nil)
    (cl:print-unreadable-object (self stream :type cl:t :identity cl:t)
      (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_key: ~s" (key self)))
      (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
        (cl:format stream " ~_value: ~s" (value self)))
      ))
  (cl:values))

(cl:defmethod pb:clear ((self attribute))
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (pb:string-field "")))
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (pb:string-field "")))
  (cl:setf (cl:slot-value self '%has-bits%) 0)
  (cl:values))

(cl:defmethod pb:is-initialized ((self attribute))
  (cl:when (cl:/= (cl:logand (cl:slot-value self '%has-bits%)
                             #b01)
                  #b01)
    (cl:return-from pb:is-initialized cl:nil))
  cl:t)

(cl:defmethod pb:octet-size ((self attribute))
  (cl:let ((size 0))
    ;; required string key = 1[json_name = "key"];
    (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'key))))
        (cl:+ s (varint:length32 s)))))
    ;; optional string value = 2[json_name = "value"];
    (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
      (cl:incf size 1)
      (cl:incf size (cl:let ((s (pb::%utf8-string-length% (cl:slot-value self 'value))))
        (cl:+ s (varint:length32 s)))))
    (cl:setf (cl:slot-value self 'pb::%cached-size%) size)
    size))

(cl:defmethod pb:serialize ((self attribute) buffer index limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index index limit)
              (cl:ignorable buffer limit))
  ;; required string key = 1[json_name = "key"];
  (cl:when (cl:logbitp 0 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 10))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'key) 'pb::%octets%))))
  ;; optional string value = 2[json_name = "value"];
  (cl:when (cl:logbitp 1 (cl:slot-value self '%has-bits%))
    (cl:setf index (varint:encode-uint32-carefully buffer index limit 18))
    (cl:setf index (wire-format:write-octets-carefully buffer index limit (cl:slot-value (cl:slot-value self 'value) 'pb::%octets%))))
  index)

(cl:defmethod pb:merge-from-array ((self attribute) buffer start limit)
  (cl:declare (cl:type com.google.base:octet-vector buffer)
              (cl:type com.google.base:vector-index start limit))
  (cl:do ((index start index))
      ((cl:>= index limit) index)
    (cl:declare (cl:type com.google.base:vector-index index))
    (cl:multiple-value-bind (field-number wire-type new-index)
        (wire-format:parse-tag buffer index limit)
      (cl:setf index new-index)
      (cl:case field-number
        ;; required string key = 1[json_name = "key"];
        ((1)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'key) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        ;; optional string value = 2[json_name = "value"];
        ((2)
          (cl:cond
            ((cl:= wire-type wire-format:+length-delimited+)
              (cl:multiple-value-bind (value new-index)
                  (wire-format:read-octets-carefully buffer index limit)
                (cl:setf (cl:slot-value self 'value) (pb:string-field value))
                (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1)
                (cl:setf index new-index)))
            (cl:t (cl:error 'wire-format:alignment))))
        (cl:t
          (cl:when (cl:= wire-type wire-format:+end-group+)
            (cl:return-from pb:merge-from-array index))
          (cl:setf index (wire-format:skip-field field-number wire-type buffer index limit)))))))

(cl:defmethod pb:merge-from-message ((self attribute) (from attribute))
  (cl:when (cl:logbitp 0 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'key) (cl:slot-value from 'key))
    (cl:setf (cl:ldb (cl:byte 1 0) (cl:slot-value self '%has-bits%)) 1))
  (cl:when (cl:logbitp 1 (cl:slot-value from '%has-bits%))
    (cl:setf (cl:slot-value self 'value) (cl:slot-value from 'value))
    (cl:setf (cl:ldb (cl:byte 1 1) (cl:slot-value self '%has-bits%)) 1))
  )


